* Configuration
  
** Personal Information  
   
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Gregor Riegler"
        user-mail-address "gregor.riegler@gmail.com")
#+END_SRC

** Load-Path
   #+begin_src emacs-lisp 
     (add-to-list 'load-path (concat user-emacs-directory "custom"))
     (add-to-list 'load-path (concat user-emacs-directory "custom/use-package"))
   #+end_src

** Cask
#+begin_src emacs-lisp 
  (require 'cask "/home/greg/.cask/cask.el")
  (cask-initialize)
#+end_src

** Package-Archives
   #+begin_src emacs-lisp 
     (require 'package)
     (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
     (package-initialize)
     
     (when (not package-archive-contents)
       (package-refresh-contents))
     
     ;; Add in your own as you wish:
     (defvar my-packages '(starter-kit starter-kit-bindings
                                       starter-kit-js starter-kit-lisp
                                       ;; Clojure & friends
                                       clojure-mode nrepl rainbow-delimiters paredit
                                       ;; Project navigation
                                       projectile magit
                                       ;; Evil
                                       evil evil-leader evil-numbers evil-paredit evil-nerd-commenter
                                       ;; Misc.
                                       ack-and-a-half auto-complete markdown-mode twilight-theme
                                       ac-nrepl ace-jump-mode ess
                                       ;; Haskell
                                       flymake-hlint haskell-mode flymake-haskell-multi hlinum
                                       )
       "A list of packages to ensure are installed at launch.")
   #+end_src
   
   Automaticaly install any missing packages
   
   #+begin_src emacs-lisp 
     (dolist (p my-packages)
       (when (not (package-installed-p p))
         (package-install p)))
   #+end_src

** Use-package
   #+begin_src emacs-lisp 
     (require 'use-package)
     (require 'bind-key)
   #+end_src

** Load the provided Clojure start kit configurations
   #+begin_src emacs-lisp 
     (load (concat user-emacs-directory "clojure-starter-kit.el"))
   #+end_src

** Miscellaneous
*** Set initial buffer
    #+begin_src emacs-lisp 
       (setq initial-buffer-choice "~/org/home.org")
    #+end_src
*** Set PATH
    #+begin_src emacs-lisp 
      (setenv "PATH" (concat (getenv "PATH") ":/home/greg/.cabal/bin:/home/greg/.cask/bin"))
    #+end_src
*** Don't fire up another backtrace when an error happens in debug mode
   
   #+begin_src emacs-lisp 
     (setq eval-expression-debug-on-error nil)
   #+end_src

*** Don't check spelling in every text-mode buffer
   #+begin_src emacs-lisp 
     (remove-hook 'text-mode-hook 'turn-on-flyspell)
   #+end_src
*** Key bindings
#+begin_src emacs-lisp 
  (global-set-key (kbd "M-l") 'forward-word)
  (global-set-key (kbd "M-h") 'backward-word)
  (global-set-key (kbd "M-a") 'find-tag)
#+end_src
**** Always indent on newline

    #+begin_src emacs-lisp 
      (global-set-key (kbd "RET") 'newline-and-indent)
    #+end_src

**** Windows
     #+begin_src emacs-lisp 
       (global-set-key (kbd "C-ä") 'delete-other-windows)
       (global-set-key (kbd "C-Ä") 'delete-window)
       (global-set-key (kbd "ö") 'other-window)
     #+end_src

*** Markdown
    #+begin_src emacs-lisp 
      (add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
      (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
      (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
    #+end_src

*** Global-auto-complete-mode
    #+begin_src emacs-lisp 
     ;; (global-auto-complete-mode f)
    #+end_src

*** Open pdfs mit envince
    #+begin_src emacs-lisp 
      (delete '("\\.pdf\\'" . default) org-file-apps)
      (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince \"%s\""))
      (add-to-list 'org-file-apps '("\\.pdf::\\([0-9]+\\)\\'" . "evince \"%s\" -p %1"))
    #+end_src
** Evil
*** Activate Evil
    #+begin_src emacs-lisp 
      (use-package evil
                   :config (progn
                             (evil-mode 1))
                   :init
                   (progn
                    (define-key evil-insert-state-map "j"
                      '(lambda ()
                         (interactive)
                         (insert "j")
                         (let ((event (read-event nil)))
                           (if (= event ?j)
                               (progn
                                 (backward-delete-char 1)
                                 (evil-normal-state))
                             (push event unread-command-events)))))
                    (global-set-key (kbd "C-S-u") 'evil-scroll-up)
                    (global-set-key (kbd "C-S-o") 'evil-execute-in-emacs-state)))
    #+end_src
*** Escape insert mode with jj
   #+begin_src emacs-lisp 
     ;; (defun evil-insert-jj-for-normal-mode ()
     ;;   (interactive)
     ;;   (insert "j")
     ;;   (let ((event (read-event nil)))
     ;;     (if (= event ?j)
     ;;       (progn
     ;;         (backward-delete-char 1)
     ;;         (evil-normal-state))
     ;;       (push event unread-command-events))))
     
     ;; (define-key evil-insert-state-map "j" 'evil-insert-jj-for-normal-mode)
   #+end_src
*** Evil-Leader
    #+begin_src emacs-lisp 
      (global-evil-leader-mode)
                     (evil-leader/set-leader ",")
      
                     (evil-leader/set-key
                       "e" 'find-file
                       "b" 'switch-to-buffer
                       "o" 'org-iswitchb
                       "w" 'save-buffer
                       "l" 'ace-jump-line-mode
                       "k" 'kill-buffer)
      
                     (evil-leader/set-key
                       "ci" 'evilnc-comment-or-uncomment-lines
                       "cl" 'evilnc-comment-or-uncomment-to-the-line)
      
    #+end_src
    #+begin_src emacs-lisp 
      ;; (global-evil-leader-mode)
      ;; (evil-leader/set-leader ",")
      
      ;; (evil-leader/set-key
      ;;   "e" 'find-file
      ;;   "b" 'switch-to-buffer
      ;;   "o" 'org-iswitchb
      ;;   "w" 'save-buffer
      ;;   "l" 'ace-jump-line-mode
      ;;   "k" 'kill-buffer)
      
      ;; (evil-leader/set-key
      ;;   "ci" 'evilnc-comment-or-uncomment-lines
      ;;   "cl" 'evilnc-comment-or-uncomment-to-the-line)
    #+end_src
*** Other
    #+begin_src emacs-lisp 
      ;; (global-set-key (kbd "C-S-u") 'evil-scroll-up)
      ;; (global-set-key (kbd "C-S-o") 'evil-execute-in-emacs-state)
    #+end_src
** Ace-Jump
#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :bind ("C-c SPC" . ace-jump-line-mode))
#+end_src
** Forth
#+begin_src emacs-lisp 
  ;; (load (conc))
  (load (concat user-emacs-directory "custom/gforth.el"))
  (autoload 'forth-mode "gforth.el")
  (setq auto-mode-alist (cons '("\\.fs\\'" . forth-mode) auto-mode-alist))
#+end_src
** Paredit
*** Key bindings
    #+begin_src emacs-lisp 
      (use-package paredit
              ;;     :commands paredit-mode
                   :init
                   (progn
                     (global-set-key (kbd "C-M-h") 'paredit-backward)
                     (global-set-key (kbd "C-M-l") 'paredit-forward)
                     (global-set-key (kbd "C-c h") 'paredit-backward-slurp-sexp)
                     (global-set-key (kbd "C-c j") 'paredit-backward-barf-sexp)
                     (global-set-key (kbd "C-c k") 'paredit-forward-barf-sexp)
                     (global-set-key (kbd "C-c l") 'paredit-forward-slurp-sexp)
                     (global-set-key (kbd "C-M-j") 'paredit-splice-sexp-killing-forward)
                     (global-set-key (kbd "C-M-k") 'paredit-splice-sexp-killing-backward)
                     (global-set-key (kbd "C-c C-s") 'paredit-split-sexp )
                     (global-set-key (kbd "C-c C-j") 'paredit-join-sexps)
                     (global-set-key (kbd "C-c C-r") 'paredit-raise-sexp)
                     (global-set-key (kbd "C-c x") 'paredit-open-curly)
                     (global-set-key (kbd "C-s-l j") 'paredit-forward-down)
                     (global-set-key (kbd "C-s-l k") 'paredit-forward-up)
                     (global-set-key (kbd "C-s-h j") 'paredit-backward-down)
                     (global-set-key (kbd "C-s-h k") 'paredit-backward-up)
                     (global-set-key (kbd "C-c (") 'paredit-wrap-round)
                     (global-set-key (kbd "C-c {") 'paredit-wrap-curly)
                     (global-set-key (kbd "C-c [") 'paredit-wrap-square)
                     ))
    #+end_src
** Org
*** Org-directory
    #+begin_src emacs-lisp 
      (setq org-directory "~/org")
    #+end_src
*** Refiling
    #+begin_src emacs-lisp 
      (defun my/org-refile-within-current-buffer ()
        "Move the entry at point to another heading in the current buffer."
        (interactive)
        (let ((org-refile-targets '((nil :maxlevel . 5))))
          (org-refile)))
      
      (global-set-key (kbd "C-c C-S-w") 'my/org-refile-within-current-buffer)
    #+end_src
*** Keywords
    #+begin_src emacs-lisp 
      (setq org-todo-keywords (quote ((sequence "TOREAD" "READ") (sequence "TODO" "DONE"))))
      (setq org-todo-keyword-faces
            '(
              ("UTODO"  . (:foreground "#b70101" :weight bold :slant italic))
              ("UTOLEARN"  . (:foreground "#b70101" :weight bold :slant italic))
              ("UTOIMPLEMENT"  . (:foreground "#b70101" :weight bold :slant italic))
              ;; ("STARTED"  . (:foreground "#b70101" :weight bold))
              ;; ("APPT"  . (:foreground "sienna" :weight bold))
              ;; ("PROJ"  . (:foreground "blue" :weight bold))
              ;; ("ZKTO"  . (:foreground "orange" :weight bold))
              ;; ("WAITING"  . (:foreground "orange" :weight bold))
              ;; ("DONE"  . (:foreground "forestgreen" :weight bold))
              ;; ("DELEGATED"  . (:foreground "forestgreen" :weight bold))
              ;; ("CANCELED"  . shadow)
              ))
    #+end_src
*** Captures
    #+begin_src emacs-lisp 
      (use-package org-protocol
                   :init (progn
                           (setq org-protocol-default-template-key "l")
                           (setq org-capture-templates
                                 '(("t" "Todo" entry (file+datetree "~/org/journal.org")
                                    "* TODO %?")
                                   ("w" "TOTWEET" entry (file+datetree "~/org/journal.org")
                                    "* TOTWEET %?")
                                   ("b" "starting with b...")
                                   ("bu" "Tobuy" entry (file+datetree "~/org/journal.org")
                                    "* TOBUY %?")
                                   ("bl" "TOBLOG" entry (file+olp "~/org/home.org" "Blog")
                                    "* TOBLOG %^{Heading}\n\t%?")
                                   ("l" "starting with l... ")
                                   ("li" "Link" entry (file+olp "~/org/bookmarks.org" "Bookmarks")
                                    "* %a\n %?\n %i")
                                   ("lb" "TOBLOG from Browser" entry (file+olp "~/org/home.org" "Blog")
                                    "* TOBLOG %?\n\t%a")
                                   ("lo" "TOLOOKAT" entry (file+datetree "~/org/journal.org")
                                    "* TOLOOKAT %?")
                                   ("lu" "TOLOOKAT from Browser" entry (file+datetree "~/org/journal.org")
                                    "* TOLOOKAT %?\n\t%a")
                                   ("lt" "TODO from Browser" entry (file+datetree "~/org/journal.org")
                                    "* TODO %?\n\t%a")
                                   ("p" "Project" entry (file+olp "~/org/projects.org" "Programming")
                                    "* %^{Heading}\n\t%?")
                                   ("r" "TOREAD" entry (file+olp "~/org/home.org" "Bücher")
                                    "* TOREAD %^{Heading}\n\t%?")
                                   ("y" "Journal prompted" item (file+datetree+prompt "~/org/journal.org")
                                    "%?")
                                   ("j" "Journal" item (file+datetree "~/org/journal.org")
                                    "%?")))
                           (define-key global-map "\C-cc" 'org-capture)))
    #+end_src
*** Agenda
    #+begin_src emacs-lisp 
      (setq org-agenda-files (list "~/org/cal.org" "~/org/bookmarks.org" "~/org/journal.org" "~/org/projects.org" "~/org/home.org" "~/org/uni.org"))
      (setq org-agenda-custom-commands
            '(("u" todo "UTODO|UTOLEARN|UTOIMPLEMENT")
              ("l" todo "TOLOOKAT")
              ("d" todo "TODO")))
      
      (setq org-agenda-skip-deadline-if-done t)
      (setq org-agenda-skip-scheduled-if-done t)
    #+end_src
**** Sometimes Agenda doesn't work
     #+begin_src emacs-lisp 
       (setq org-agenda-archives-mode nil)
       (setq org-agenda-skip-comment-trees nil)
       (setq org-agenda-skip-function nil)
     #+end_src
*** Calendar
    #+begin_src emacs-lisp 
      (load-file "~/.emacs.d/custom/org-caldav.el")
      (load-file "~/.emacs.d/custom/org-import-calendar.el")
      (use-package org-caldav
                   :init (progn 
                           (setq org-icalendar-exclude-tags (quote ("training")))
                           (setq org-icalendar-include-body nil)
                           (setq org-icalendar-use-scheduled (quote nil))
                           (define-key evil-normal-state-map (kbd "C-p") 'org-caldav-sync)
                           
                           (global-set-key (kbd "C-ü")
                                           '(lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([134217848 111 114 103 45 99 97 108 100 97 118 45 115 121 110 99 return 111 114 46 114 105 101 103 108 101 114 64 103 109 97 105 108 46 99 111 109 return 119 97 97 114 115 110 118 116 102 120 102 120 121 112 118 106 return] 0 "%d")) arg)))
                           (setq org-caldav-calendar-id "vpvsjgj9avredjnv58kt85lklo@group.calendar.google.com")
                           (setq org-icalendar-timezone "UTC")
                           (setq org-caldav-inbox "~/org/cal.org")
                           (setq org-caldav-files (list "~/org/home.org" "~/org/uni.org"))
                           (setq org-caldav-sync-changes-to-org 'title-only)
                           (setq org-icalendar-include-todo nil)
                           (setq org-icalendar-store-UID t)
                           ))
    #+end_src
*** General
    #+begin_src emacs-lisp 
      (setq org-refile-targets (quote ((org-agenda-files :maxlevel . 2))))
      (setq org-M-RET-may-split-line (quote ((default))))
      (setq org-goto-interface 'outline org-goto-max-level 10)
      (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
      (global-set-key "\C-cL" 'org-store-link)
      (global-set-key "\C-ca" 'org-agenda)
      (global-set-key (kbd "M-o") 'imenu)
      (setq org-log-done 'time)
      (setq org-clock-persist 'history)
      (org-clock-persistence-insinuate)
      (setq org-return-follows-link t)
    #+end_src

    #+RESULTS:
    : t

*** Org-drill
    #+begin_src emacs-lisp 
      (load-file "~/.emacs.d/custom/org-drill.el")
      (use-package org-drill
        :init (progn (setq org-drill-learn-fraction 0.45)
                     (setq org-drill-match "-nodrill")))
    #+end_src
*** Org-learn
    #+begin_src emacs-lisp 
      (load-file "~/.emacs.d/custom/org-learn.el")
      (require 'org-learn)
    #+end_src
*** Org-mobile
    #+begin_src emacs-lisp 
      (setq org-mobile-inbox-for-pull "~/org/notes.org")
      (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
    #+end_src
*** Org-Babel
    #+begin_src emacs-lisp 
      (setq org-src-fontify-natively t)
      (setq org-confirm-babel-evaluate nil)
      (setq org-src-window-setup 'current-window)
    #+end_src
**** Emacs-lisp
     #+begin_src emacs-lisp 
       (eval-after-load 'org
              '(add-to-list 'org-structure-template-alist
                           '("x" "#+begin_src emacs-lisp \n?\n#+end_src", "<src lang='emacs-lisp'>\n?\n</src>")))
       
     #+end_src
**** R
     #+begin_src emacs-lisp 
       (eval-after-load 'org
         (progn
           '(add-to-list 'org-structure-template-alist
                         '("r"  "#+begin_src R :results silent :session sess1\n?\n#+end_src", "<src lang='R'>\n?\n</src>"))
           '(org-babel-do-load-languages
             'org-babel-load-languages
             '((emacs-lisp . t)
               (R . t)))
           ))
     #+end_src
           
#+begin_src emacs-lisp 
  (require 'ess)
#+end_src
**** Clojure
     #+begin_src emacs-lisp 
       (add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj"))
       
       (defvar org-babel-default-header-args:clojure 
         '((:results . "silent")))
       
       (defun org-babel-execute:clojure (body params)
         "Execute a block of Clojure code with Babel."
         (nrepl-interactive-eval body))
       
       (add-hook 'org-src-mode-hook
                 '(lambda ()
                    (set (make-local-variable 'nrepl-buffer-ns) 
                         (with-current-buffer 
                             (overlay-buffer org-edit-src-overlay)
                           nrepl-buffer-ns))))
       (provide 'ob-clojure)
       (eval-after-load 'org
              '(add-to-list 'org-structure-template-alist
                           '("c" "#+begin_src clojure :tangle src/\n?\n#+end_src", "<src lang='clojure'>\n?\n</src>")))
     #+end_src
**** Haskell
     #+begin_src emacs-lisp 
       (load-file "~/.emacs.d/custom/ob-haskell.el")
     #+end_src
*** Org-attach
    #+begin_src emacs-lisp 
      (require 'org-attach)
      (org-add-link-type "att" 'org-attach-open-link)
      (defun org-attach-open-link (file)
        (org-open-file (org-attach-expand file)))
      (set-variable 'org-attach-store-link-p t)
    #+end_src
*** Org-dotemacs
#+begin_src emacs-lisp 
  (setq org-dotemacs-default-file (concat user-emacs-directory "configuration.org"))
#+end_src
*** Latex
**** Include Bibtex call
#+begin_src emacs-lisp 
  (use-package org-latex
    :init (progn
            (setq org-latex-create-formula-image-program 'dvipng)
            (setq org-latex-pdf-process '("pdflatex -interaction nonstopmode -output-directory %o %f""pdflatex -interaction nonstopmode -output-directory %o %f" "bibtex %b" "pdflatex -interaction nonstopmode -output-directory %o %f"))
            (add-to-list 'org-latex-classes
                         '("termpaper"
                           "\\documentclass{article}
                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                           ("\\section{%s}" . "\\section*{%s}")
                           ("\\subsection{%s}" . "\\subsection*{%s}")
                           ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                           ("\\paragraph{%s}" . "\\paragraph*{%s}")
                           ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
                         )
            ))
  
#+end_src
**** Beamer
#+begin_src emacs-lisp 
  (use-package ox-beamer)
#+end_src
** Haskell
*** Settings
    #+begin_src emacs-lisp 
      (setq haskell-hoogle-command nil) 
      ;; (setq haskell-hoogle-command "hoogle")
      (setq haskell-package-conf-file "/home/greg/.ghc/x86_64-linux-7.4.1/package.conf")
      (setq haskell-process-path-cabal-dev "/usr/bin/cabal-dev")
      (setq haskell-process-path-ghci "ghci")
      (setq haskell-process-prompt-restart-on-cabal-change nil)
      (setq haskell-process-suggest-language-pragmas nil)
      (setq haskell-process-type (quote ghci))
      (setq haskell-process-args-ghci '("-package-conf" "cabal-dev/packages-7.4.1.conf" "-i../dist/build/autogen" "-idist/build/autogen" "-XOverloadedStrings"))
      (setq haskell-program-name "cabal-dev ghci")
      (setq haskell-stylish-on-save t)
      (setq haskell-tags-on-save nil)
      (setq inferior-haskell-web-docs-base "http://hackage.haskell.org/packages/archive/")
    #+end_src
*** Hooks
   #+begin_src emacs-lisp 
     (eval-after-load "haskell-mode"
       '(progn
         (define-key haskell-mode-map (kbd "C-x C-d") nil)
         (define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
         (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
         (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-file)
         (define-key haskell-mode-map (kbd "C-c C-b") 'haskell-interactive-switch)
         (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
         (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
         (define-key haskell-mode-map (kbd "C-c M-.") nil)
         (define-key haskell-mode-map (kbd "C-c C-d") nil)))
     (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
     (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
     (add-hook 'haskell-mode-hook 'flymake-haskell-multi-load)
     (defun haskell-hook ()
       (define-key evil-normal-state-map (kbd "M-.") 'find-tag)
       (define-key haskell-mode-map (kbd "C-#") 'haskell-interactive-bring)
       )
     (defun haskell-cabal-hook ()
       (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
       (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)
       (define-key haskell-cabal-mode-map (kbd "C-#") 'haskell-interactive-bring)
       (define-key haskell-cabal-mode-map [?\C-c ?\C-z] 'haskell-interactive-switch))
     (add-hook 'haskell-cabal-mode-hook 'haskell-cabal-hook)
     (add-hook 'haskell-mode-hook 'haskell-hook)
   #+end_src
*** Flymake
    #+begin_src emacs-lisp 
      (setq flymake-gui-warnings-enabled nil)
      (global-set-key (kbd "C-c e") 'flymake-display-err-menu-for-current-line)
      (global-set-key (kbd "C-c C-n") 'flymake-goto-next-error)
      (global-set-key (kbd "C-c C-p") 'flymake-goto-next-error)
    #+end_src
** Projectile
   #+begin_src emacs-lisp 
     (setq projectile-use-native-indexing t)
   #+end_src
** Clojure
*** Nrepl
**** Key bindings
     #+begin_src emacs-lisp 
       (use-package ac-nrepl
                    :commands nrepl-mode
                    :init (progn
                            (add-hook 'nrepl-mode-hook 'ac-nrepl-setup)
                            (add-hook 'nrepl-interaction-mode-hook 'ac-nrepl-setup)
                            (eval-after-load "auto-complete"
                              '(add-to-list 'ac-modes 'nrepl-mode))
                            (add-hook 'auto-complete-mode-hook '(lambda () (setq completion-at-point-functions '(auto-complete))))
                            (add-hook 'nrepl-mode-hook 'set-auto-complete-as-completion-at-point-function)
                            (add-hook 'nrepl-interaction-mode-hook 'set-auto-complete-as-completion-at-point-function)
                ;;            (define-key nrepl-interaction-mode-map (kbd "C-c C-d") 'ac-nrepl-popup-doc)
))     
     #+end_src

     #+begin_src emacs-lisp 
       ;; (defun set-auto-complete-as-completion-at-point-function ()
       ;;   (setq completion-at-point-functions '(auto-complete)))
       ;; (global-set-key (kbd "C-;") 'nrepl-jump-back)
       ;; (global-set-key (kbd  "C-:") 'nrepl-jump)
       
       ;; (require 'ac-nrepl)
       ;; (add-hook 'nrepl-mode-hook 'ac-nrepl-setup)
       ;; (add-hook 'nrepl-interaction-mode-hook 'ac-nrepl-setup)
       ;; (eval-after-load "auto-complete"
       ;;   '(add-to-list 'ac-modes 'nrepl-mode))
       ;; (add-hook 'auto-complete-mode-hook '(setq completion-at-point-functions '(auto-complete)))
       ;; (add-hook 'nrepl-mode-hook 'set-auto-complete-as-completion-at-point-function)
       ;; (add-hook 'nrepl-interaction-mode-hook 'set-auto-complete-as-completion-at-point-function)
       ;; (define-key nrepl-interaction-mode-map (kbd "C-c C-d") 'ac-nrepl-popup-doc)
     #+end_src
** Common Lisp
   #+begin_src emacs-lisp 
     (setq inferior-lisp-program "/usr/bin/clisp")
   #+end_src
